# Что такое монада?

В 7-м уроке мы пытались ответить на вопрос "что такое функциональное программирование?". Мы говорили, что есть элементы ФП, такие как иммутабельность, рекурсия, функции высшего порядка, сопоставление с образцом и др. И функциональное программирование -- это то, что состоит **в основном** из этих элементов.

Теперь мы попробуем копнуть глубже, и разобраться что такое **монада**. Есть шутка, что каждый новичок, приходящий в Хаскель, обязательно придумывает своё объяснение монад. Таких объяснений существует действительно много. И часто они слишком абстрактны, не дают понимания, какая от всего этого практическая польза.

Поэтому мы начали не с теории, а с практики. Мы уже применили монады и операции над ними, решили с их помощью прикладную задачу. После этого проще понять теорию.

## Примеры монад

Монада -- это значение, обернутое в некоторый полезный контекст. Например:

```elixir
{:ok, book} = Bookshop.Controller.validate_book(data)
```

Здесь значение `book` обернуто в контекст `{:ok, book}`, и этот контекст несет информацию о том, что получен успешный результат.

```elixir
{:error, :book_not_found} = Bookshop.Controller.validate_book(data)
```

Здесь значение `:book_not_found` обёрнуто в контекст `{:error, ...}`, и этот контекст несет информацию о том, что получена ошибка.

Это монада **Result**, которая описывается типом:

```elixir
{:ok, successful_value} | {:error, error_value}
```

Это одна из самых популярных монад, она есть практически во всех ФП языках и во многих не ФП языках:
- Haskell `Result e t`
- OCaml `('e, 't) result`
- Rust `Result<T, E>`
- Scala `Either[E, T]`

Другая популярная монада -- **Maybe** (или **Option**, в разных языках называется по-разному). Здесь контекст несет информацию о том, существует значение или не существует:

```elixir
> m = %{a: 42}
> Map.fetch(m, :a)
{:ok, 42}
> Map.fetch(m, :b)
:error
```

Maybe описывается типом:

```elixir
{:ok, value} | :no_value
```

Как видим, это упрощенный Result. Здесь есть `successful_value`, но нет `error_value`, а только сам контекст `:no_value`.

Еще одна полезная монада -- **Future**:

```elixir
> future_value = Task.async(fn() -> 42 end)
%Task{
  owner: #PID<0.107.0>,
  pid: #PID<0.113.0>,
  ref: #Reference<0.3496306138.1615593474.196666>
}
> Task.await(future_value)
42
```

Здесь значение изначально отсутствует, есть только контекст о том, что запущено вычисление. Но позже значение появляется.

## Оператор bind

Вспомним тему урока -- композиция функций. Вспомним 4-е решение, где мы реализовали функцию bind:

```elixir
@spec bind(m_fun(), m_fun()) :: m_fun()
def bind(f1, f2) do
  fn args ->
    case f1.(args) do
      {:ok, result} -> f2.(result)
      {:error, error} -> {:error, error}
    end
  end
end
```

и применили ее для композиции функций:

```elixir
f =
  FP.bind(&C.validate_incoming_data/1, &step_validate_cat/1)
  |> FP.bind(&step_validate_address/1)
  |> FP.bind(&step_validate_books/1)
  |> FP.bind(&step_create_order/1)

f.(data)
```

bind делает композицию двух функций, которые принимают обычное значение, а возвращают монаду Result. Мы могли бы реализовать аналогичный bind для функций, возвращающих монады Maybe или Future.

Реализация для Maybe практически не отличается от реализации для Result. Поэтому давайте рассмотрим пример с Feature.

Представим, что у нас есть несколько асинхронных функций, которые делают запросы в разные сервисы. Нам нужно сделать несколько запросов, получить все результаты, и сделать некий суммарный результат:

```elixir
future1 = request_service_1()
value1 = Task.await(future1)

future2 = request_service_2()
value2 = Task.await(future2)

future3 = request_service_3()
value3 = Task.await(future3)
```

Мы могли бы реализовать функцию `bind_async`, делающую композицию из таких асинхронных функций.


```elixir
bind_async(
  &request_service_1/0, 
  &request_service_2/0
)
|> bind_async(&request_service_3/0)
```

Это может быть простая реализация, которая делает блокировку после каждого вызова, дожидается результата, затем делает следущий вызов.

Или это может быть более сложная реализация, которая запускает все вызовы паралельно, ждёт все результаты, затем возвращает их.

Или это может быть ещё более сложная реализация, которая учитывает зависимость функций друг от друга, запускает последовательно зависимые функции и параллельно независимые.


## Что общего есть у всех монад?

Польза от Result и Future очевидна. Но почему они собраны в некую общую группу с названием "монады"? Что их объединяет?

Как мы видим, их объединяет возможность делать композицию функций с помощью bind.

```
validate_book
>>= buy_book
>>= deliver_book

request_service_1
>>= request_service_2
>>= request_service_3
```

Нам понадобились две разные bind для Result и для Future. Но вспомним, что в Эликсир есть протоколы: Enumerable, Inspect, String.Chars и др. Они позволяют делать одинаковые операции над разными типами данных. Если бы в Эликсир существовал протокол Monad, то можно было бы реализовать один bind для всех монад. В Хаскеле это так и есть.

(В языке и стандартной библиотеке Эликсир нет монад, но есть библиотека [Monad](https://hexdocs.pm/monad/Monad.html), реализующая некоторые монады и операции над ними.

## Другие операции над монадами

Давайте обозначим простое значение `v`, а значение обернутое в монаду `M<v>`.

У нас могут быть функции:

```elixir
f1(v) :: v
f2(v) :: M<v>
f3(M<v>) :: v
f4(M<v>) :: M<v>
```

Все эти варианты нужно комбинировать между собой.

bind работает для f2: `f2 >>= f2`.

Для f1 и f4 подходит обычный pipe: `f1 |> f1`, `f4 |> f4`.

Для f3 нужно нечто противоположное bind. Что-то, что заворачивает простое значение в монаду. В Хаскеле для этого есть оператор `return`. (Название, конечно, сбивает с толку, тут return не имеет никакого отношения к возврату значения.)

Для монады Result это можно реализовать так:

```elixir
def wrap_into_result(val), do: {:ok, val}
```

И композиция функций выглядела бы так `f3 |> wrap_into_result |> f3`.

Для f1 и f4 в Хаскеле предусмотрены разные операторы: `f1 . f1`, `f4 >> f4`. Но в Эликсир нам это не нужно.

## Функциональная программа -- это композиция функций

В теории любая функциональная программа сводится к цепочке функций, скомпонованых друг с другом разными способами:

```haskell
f1 >>= f2 . f3 >> f4 >>= f5 . f6
```

Цепочка представляет собой happy path, а операторы композиции скрывают все ветвления в коде. То есть мы получаем то же самое, как если бы использовали исключения для control flow. В некотором роде эти два подхода (монады и исключения) альтернативны друг другу.

Но не всё так просто. Если мы пойдем по пути композиции, то столкнёмся с каррированием и монадными трансформерами.

## Каррирование (Currying)

Описаные выше варианты композиции работают для функций с одним аргументом. А что, если аргументов больше?

```elixir
def not_curried_fun(a, b, c) do
  a + b + c
end

> FP.not_curried_fun(1, 2, 3)
6
```

Здесь помогает каррирование. Функцию f/3 можно представить как функцию f/1, возвращающую f/2. А функцию f/2 можно представить, как f/1, возвращающую f/1:

```elixir
def curried_fun(a) do
  fn(b) ->
    fn(c) -> a + b + c end
  end
end
```

Её можно вызывать со всеми аргументами сразу:

```elixir
iex(3)> FP.curried_fun(1).(2).(3)
6
```

Или можно вызвать с одним аргументом и в результате получить частично-применённую функцию, где 1-й аргумент уже применился, а 2 других ещё нет:

```elixir
iex(4)> f1 = FP.curried_fun(1)
#Function<1.15736367/1 in FP.curried_fun/1>
```

Частично-применённую функцию тоже можно вызвать со всеми оставшимися аргументами или с одним аргументом:

```elixir
iex(5)> f1.(2).(3)
6
iex(6)> f2 = f1.(2)
#Function<3.15736367/1 in FP.curried_fun/1>
```

И в конце остается частично-применённая функция, которой не хватает одного аргумента:

```elixir
iex(7)> f2.(3)
6
```

Таким образом любую функцию можно представить как функцию от одного аргумента. В Эликсир это возможно, но совершенно непрактично. А в Хаскель это работает автоматически для любой функции.

За счёт каррирования мы можем применять все способы композиции ко всем функциям.


## Монадные трансформеры

На пути композиции рано или поздно мы столкнемся с монадами, вложенными друг в друга:

```elixir
Result<Maybe<v>>
Future<Maybe<Result<v>>>
```

И тогда нам понадобятся преобразования одних монад в другие. Для этого используются монадные трансформеры.

Например, наша функция `FP.sequence/1` является монадным трансформером. Она преобразует `[ Result<Book.t, Error> ]` в `Result< [Book.t], Error>`. То есть преобразует список над Result в Result над списком.

## Выводы

В разных ФП языках монады и композиция функций поддерживаются на разном уровне. Лучше всего они развиты в **Haskell** и **Scala**. Похуже в **OCaml** и **F#**.

В **Elixir** поддержка монад откровенно слабая. На практике удобно пользоваться **pipe**, **pipeline**, **with** и не более того. Поэтому широко применяются исключения, с ними как-то проще. А главное, привычнее, ведь в Эликсир приходят люди из императивных языков, не знакомые с монадами.

Противоположный пример -- язык **Rust**. В нём нет исключений, а есть panic, которую нельзя перехватить. Panic всегда завершает текущий процесс, поэтому её нельзя использовать для control flow. Остаётся только один путь -- монады. И они поддерживаются в Rust на хорошем уровне.

В 80-90-х годах победило императивное программирование. Это случилось потому, что оно гораздо эффективнее использовало имеющиеся ресурсы: CPU и память. А ресурсы тогда были в дефиците.

Если бы победило функциональное программирование, то сегодня код выглядел бы совершенно иначе :smiley:
