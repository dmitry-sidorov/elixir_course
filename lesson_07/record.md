# Record

Запись (Record) -- важная структура данных для Эрланг, но в Эликсир она используется редко. Обычно она используется в случаях, когда нужно работать с Эрланг библиотекой, в АПИ которой используются Record.

В Эликсир разработке используется много Эрланг библиотек. Популярные библиотеки имеют Эликсир обертки, которые адаптируют АПИ в более удобный для Эликсир вид. Менее популярные библиотеки могут не иметь таких оберток, и тогда придется иметь дело с их АПИ, и в том числе иметь дело с Record.

Это не единственная причина, почему Record включены в курс. Но об этом ниже.

Чтобы понять, что такое Record, нужно вернуться к кортежам.

Кортеж можно рассматривать как урезаную KV структуру, из которой убрали Key и оставили только Value. Мы пользовались такими структурами в начале курса:

```
{:point, x1, y1}
{:rect, left_top, right_bottom}
```
Это вполне работает, когда у нас есть 2-3 значения, и ключи понятны из контекста. 4 значения работают уже хуже:
```
{:user, 1, "Bob", 23}
```
"Bob" -- понятно, имя.
1 -- ну тут должно быть id, значит это id.
А 23 -- это что?

5, 6 и больше значений работают совсем плохо.

И тут на помощь приходит Record. Это синтаксический сахар поверх кортежа, который добавляет отсутствующие ключи. Правда добавляет только в исходном коде, а в скомпилированном байткоде ключей уже нет. На этапе компиляции все Record превращаются в обычные кортежи.


## Расмотрим пример

Смоделируем наш любимый event еще раз, используя Record:
lib/model/record_event.ex

В iex консоли мы видим кортежи:
```
iex(1)> my_event = RecordExample.create()
{:event, "Team Meeting", ~U[2021-03-10 19:40:00.000000Z],
 {:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178},
  {:room, 6, 610}},
 [
   {:participant, :human, "Helen", :project_manager},
   {:participant, :cat, "Tihon", :cate}
 ], [{:topic, :medium, "buying food for cat"}]}
```

Модуль Record автоматически создает макросы, позволяющие извлекать данные по ключу:
```
> alias Model.RecordEvent.Event, as: E
> require E
> E.event(ev, :title)
"Team Meeting"
> loc = E.event(my_event, :location)
{:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178}, {:room, 6, 610}}

> alias Model.RecordEvent.Location, as: L
> require L
> L.location(loc, :room)
{:room, 6, 610}
```

И модифицировать данные по ключу:
```
> my_event = E.event(my_event, title: "Food for cat")
{:event, "Food for cat", ~U[2021-03-10 19:40:00.000000Z],

> rm = L.location(loc, :room)
{:room, 6, 610}
> alias Model.RecordEvent.Room, as: R
> require R
> rm = R.room(rm, number: 611)
{:room, 6, 611}
> loc = L.location(loc, room: rm)
{:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178},
 {:room, 6, 611}}
> my_event = E.event(my_event, location: loc)
{:event, "Food for cat", ~U[2021-03-10 19:40:00.000000Z],
 {:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178},
  {:room, 6, 611}},
  ...
```


## Но зачем нам это все, если есть Struct?

Есть две причины: идеология и производительность.

Идеологическая причина в том, что мы хотим иметь структуру данных с фиксированным набором полей. Struct только имитирует фиксированный набор полей, и эту имитацию при желании можно обойти. Тогда как Record предоставляет именно то, что нужно.

По производительности Struct и Record тоже отличаются. Struct -- это синтаксически сахар поверх Map, а Record -- это синтаксический сахар поверх кортежа. Так что мы сравниваем Map и кортеж.

Внутреннее представление кортежа в BEAM -- это C-struct, структура языка С, где значения размещены в памяти компактно друг за другом. Такая структура занимает мало места в памяти, и все операции с ней быстрые и эффективные.

Внутренее представление Map зависит от размера. Для небольших Map это flatmap. Для больших это довольно сложная штука под названием Hash array mapped trie, сочетающая характеристики хэш-таблицы и префиксного дерева. Впрочем, трудно будет создать настолько большую Struct, что для нее понадобится такое дерево.

Так что речь пойдет о flatmap. Это сортированный список ключей и значений. Памяти он занимает немного больше, потому что нужно хранить еще и ключи, а не только значения, как в кортеже. Операции с ним требуют немного больше CPU, так как нужно поддерживать сортировку.

В целом разница между небольшими Map и кортежами не большая. Но она имеет значение, когда мы передаём данные между процессами. В этом случае данные полностью копируются из памяти одного процесса в память другого. А если процессы находятся на разных узлах кластера, то данные еще передаются по сети.


```elixir
> CompareStructRecord.start()
14272 bytes for %Model.TypedEvent.Event{agenda: [%Model.TypedEvent.Topic{...}, ...], datetime: ~U[2021-03-10 19:40:00.000000Z], ...}
9472 bytes for {:event, "Team Meeting", ...}
512 bytes for %{a: 42, b: 1000}
192 bytes for {42, 1000}
256 bytes for [42, 1000]
142400 bytes for [%Model.TypedEvent.Event{agenda: [...], ...}, %Model.TypedEvent.Event{...}, ...]
137600 bytes for [{:event, ...}, {...}, ...]
```

### Особенности Record

- Основной способ моделирования данных в Эрланг (в Эликсир это Struct)
- Сложнее сериализировать в JSON, для работы с БД (не совместим с Ecto)
- Только Record/Tuple можно хранить ETS и применять select/match.


### Недостатки Record

Основной недостаток -- отсутствие информации об именах ключей во время выполнения. Это сильно затрудняет сериализацию/десериализацию, например, в JSON, или в протоколах общения с базами данных.

Поэтому в Эрланге нет библиотек, похожих на Ecto. А попытки создать веб-фреймворк, похожий на Ruby on Rails предпринимались, но не стали успешными.

Так же нет удобных средств для работы с вложенными структурами данных, типа **get_in**, **put_in**, **update_in**.
