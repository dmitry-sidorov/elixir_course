## Protocol vs Behaviour

TODO


## Алгебраические типы данных

Теперь немного теории. В функциональном программировании есть понятие Алгебраических типов данных, ADT (Algebraic data type). Суть их в том, что для данных определены некоторые алгебраические операции, позволяющие создавать более сложные данные.

Например, Event -- это название И время И место И участники И агенда. Это **произведение (умножение, product)** данных.

Самое простое произведение -- это кортеж:

```elixir
{:event, "Team Meeting", datetime, location, participants, agenda}
```

В языке OCaml тип кортежа так и обозначается -- через знак умножения:

```
String * Datetime * Participant list * Topic list
```

Struct -- это тоже произведение:

```elixir
%Event.Event{
  title: "Team Meeting",
  datetime: ~U[2021-03-10 19:40:00.000000Z],
  location: location,
  participants: [helen, bob, kate, tihon],
  agenda: agenda
}
```

Теперь посмотрим на `%Event.Participant.species` и `%Event.Participant.role`.
В нашем примере встречаются два вида species -- это `:human` ИЛИ `:cat`.
И встречаются три вида role -- это `:project_manager` ИЛИ `:developer` ИЛИ `:cat`.

Это **перечисление (сумма, sum)** данных.

Во многих языках для этого есть тип Enum, который определяет конечное множество значений. Например, в OCaml это было бы так:

```
data Species = Human | Cat
data Role = ProjectManager | Developer | Cat
```

И компилятор не позволит присвоить какие-либо другие значения, кроме перечисленных.

К сожалению, в Эликсир нет типа Enum на уровне компилятора. Но можно описать этот тип для dialyzer:

```elixir
@type species :: :human | :cat
@type role :: :project_manager | :developer | :cat
```

(Зато в Elixir есть модуль Enum, что вносит некоторую путаницу. Название совсем неудачное, правильно было бы назвать этот модуль -- Collection).

Произведение и сумма (product & sum) позволяют описать любые объекты. Раньше мы говорили, что кортеж и список позволяют моделировать любые объекты. ADT -- это другой уровень абстракции. На этом уровне не различаются одиночный элемент и список элементов. Зато определяются способы композиции данных для создания новых, более сложных данных.

Какая же от всего этого польза? Это математический аппарат, который используется при создании системы типов в некоторых языках программирования, особенно в функциональных языках.

В языках с полноценной реализацией ADT (это, например, OCaml, Haskell, Scala, F#), при применении pattern matching к типу Enum проверяется, что в шаблонах использованы все возможные значения:

```elixir
case tihon.species do
  :human -> do_something
  :cat -> do_something_else
end

case tihon.role do
  :cat -> do_something
  :developer -> do_something_else
end
```

В таких языках первый пример скомпилировался бы успешно, а во втором примере компилятор выдал бы ошибку, что не использовано значение :project_manager. Это важно при изменениях в данных, когда добавляется новое значение в Enum, и нужно найти и обновить все места в коде, где эти данные обрабатываются.

Увы, Elixir и dialyzer этого не делают.

# Record

Запись (Record) -- важная структура данных для Эрланг, но в Эликсир она используется редко. Обычно она используется в случаях, когда нужно работать с Эрланг библиотекой, в АПИ которой используются Record.

В Эликсир разработке используется много Эрланг библиотек. Популярные библиотеки имеют Эликсир обертки, которые адаптируют АПИ в более удобный для Эликсир вид. Менее популярные библиотеки могут не иметь таких оберток, и тогда придется иметь дело с их АПИ, и в том числе иметь дело с Record.

Это не единственная причина, почему Record включены в курс. Но об этом ниже.

Чтобы понять, что такое Record, нужно вернуться к кортежам.

Кортеж можно рассматривать как урезаную KV структуру, из которой убрали Key и оставили только Value. Мы пользовались такими структурами в начале курса:

```
{:point, x1, y1}
{:rect, left_top, right_bottom}
```
Это вполне работает, когда у нас есть 2-3 значения, и ключи понятны из контекста. 4 значения работают уже хуже:
```
{:user, 1, "Bob", 23}
```
"Bob" -- понятно, имя.
1 -- ну тут должно быть id, значит это id.
А 23 -- это что?

5, 6 и больше значений работают совсем плохо.

И тут на помощь приходит Record. Это синтаксический сахар поверх кортежа, который добавляет отсутствующие ключи. Правда добавляет только в исходном коде, а в скомпилированном байткоде ключей уже нет. На этапе компиляции все Record превращаются в обычные кортежи.


## Расмотрим пример

Смоделируем наш любимый event еще раз, используя Record:
lib/model/record_event.ex

В iex консоли мы видим кортежи:
```
iex(1)> my_event = RecordExample.create()
{:event, "Team Meeting", ~U[2021-03-10 19:40:00.000000Z],
 {:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178},
  {:room, 6, 610}},
 [
   {:participant, :human, "Helen", :project_manager},
   {:participant, :cat, "Tihon", :cate}
 ], [{:topic, :medium, "buying food for cat"}]}
```

Модуль Record автоматически создает макросы, позволяющие извлекать данные по ключу:
```
> alias Model.RecordEvent.Event, as: E
> require E
> E.event(ev, :title)
"Team Meeting"
> loc = E.event(my_event, :location)
{:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178}, {:room, 6, 610}}

> alias Model.RecordEvent.Location, as: L
> require L
> L.location(loc, :room)
{:room, 6, 610}
```

И модифицировать данные по ключу:
```
> my_event = E.event(my_event, title: "Food for cat")
{:event, "Food for cat", ~U[2021-03-10 19:40:00.000000Z],

> rm = L.location(loc, :room)
{:room, 6, 610}
> alias Model.RecordEvent.Room, as: R
> require R
> rm = R.room(rm, number: 611)
{:room, 6, 611}
> loc = L.location(loc, room: rm)
{:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178},
 {:room, 6, 611}}
> my_event = E.event(my_event, location: loc)
{:event, "Food for cat", ~U[2021-03-10 19:40:00.000000Z],
 {:location, {:address, "Belarus", "Minsk", "Partizanskij pr", 178},
  {:room, 6, 611}},
  ...
```


## Но зачем нам это все, если есть Struct?

Есть две причины: идеология и производительность.

Идеологическая причина в том, что мы хотим иметь структуру данных с фиксированным набором полей. Struct только имитирует фиксированный набор полей, и эту имитацию при желании можно обойти. Тогда как Record предоставляет именно то, что нужно.

По производительности Struct и Record тоже отличаются. Struct -- это синтаксически сахар поверх Map, а Record -- это синтаксический сахар поверх кортежа. Так что мы сравниваем Map и кортеж.

Внутреннее представление кортежа в BEAM -- это C-struct, структура языка С, где значения размещены в памяти компактно друг за другом. Такая структура занимает мало места в памяти, и все операции с ней быстрые и эффективные.

Внутренее представление Map зависит от размера. Для небольших Map это flatmap. Для больших это довольно сложная штука под названием Hash array mapped trie, сочетающая характеристики хэш-таблицы и префиксного дерева. Впрочем, трудно будет создать настолько большую Struct, что для нее понадобится такое дерево.

Так что речь пойдет о flatmap. Это сортированный список ключей и значений. Памяти он занимает немного больше, потому что нужно хранить еще и ключи, а не только значения, как в кортеже. Операции с ним требуют немного больше CPU, так как нужно поддерживать сортировку.

В целом разница между небольшими Map и кортежами не большая. Но она имеет значение, когда мы передаём данные между процессами. В этом случае данные полностью копируются из памяти одного процесса в память другого. А если процессы находятся на разных узлах кластера, то данные еще передаются по сети.


```elixir
> CompareStructRecord.start()
14272 bytes for %Model.TypedEvent.Event{agenda: [%Model.TypedEvent.Topic{...}, ...], datetime: ~U[2021-03-10 19:40:00.000000Z], ...}
9472 bytes for {:event, "Team Meeting", ...}
512 bytes for %{a: 42, b: 1000}
192 bytes for {42, 1000}
256 bytes for [42, 1000]
142400 bytes for [%Model.TypedEvent.Event{agenda: [...], ...}, %Model.TypedEvent.Event{...}, ...]
137600 bytes for [{:event, ...}, {...}, ...]
```

### Особенности Record

- Основной способ моделирования данных в Эрланг (в Эликсир это Struct)
- Сложнее сериализировать в JSON, для работы с БД (не совместим с Ecto)
- Только Record/Tuple можно хранить ETS и применять select/match.


### Недостатки Record

Основной недостаток -- отсутствие информации об именах ключей во время выполнения. Это сильно затрудняет сериализацию/десериализацию, например, в JSON, или в протоколах общения с базами данных.

Поэтому в Эрланге нет библиотек, похожих на Ecto. А попытки создать веб-фреймворк, похожий на Ruby on Rails предпринимались, но не стали успешными.

Так же нет удобных средств для работы с вложенными структурами данных, типа **get_in**, **put_in**, **update_in**.
