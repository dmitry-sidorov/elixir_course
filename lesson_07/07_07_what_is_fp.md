# Алгебраические типы данных

Рассмотрим ещё немного теории. В функциональном программировании есть понятие Алгебраических типов данных, ADT (Algebraic data type). Суть их в том, что для данных определены некоторые алгебраические операции, позволяющие создавать более сложные данные.

Например, Event -- это название И время И место И участники И агенда. Это **произведение (умножение, product)** данных.

Самое простое произведение -- это кортеж:

```elixir
{:event, title, place, time, participants, agenda}
```

В языке OCaml тип кортежа так и обозначается -- через знак умножения:

```
String * Place * DateTime * Participant list * Topic list
```

Структура -- это тоже произведение:

```elixir
event = %TS.Event{
  title: "Team Meeting",
  place: place,
  time: time,
  participants: participants,
  agenda: agenda
}
```

Теперь посмотрим на `%TS.Topic.priority`. В нашем примере встречаются три вида приоритетов: `:high | :medium | :low` Это **перечисление (сумма, sum)** данных.

Во многих языках для этого есть тип Enum, который определяет конечное множество значений. И компилятор не позволит присвоить какие-либо другие значения, кроме перечисленных.

В Эликсир такой тип можно описать для Dialyzer:

```elixir
@type priority :: :high | :medium | :low
```

Произведение и сумма (product & sum) позволяют описать любые объекты. Раньше мы говорили, что кортеж и список позволяют моделировать любые объекты. ADT -- это другой уровень абстракции. На этом уровне не различаются одиночный элемент и список элементов. Зато определяются способы композиции данных для создания новых, более сложных данных.

Какая же от всего этого польза? Это математический аппарат, который используется при создании системы типов в некоторых языках программирования, особенно в функциональных языках.

В языках с полноценной реализацией ADT (это, например, OCaml, Haskell, Scala, F#), при применении pattern matching к типу Enum проверяется, что в шаблонах использованы все возможные значения:

```elixir
case topic.priority do
  :high -> do_something
  :medium -> do_something_else
  :low -> do_something_else
end
```

И если какого-то значения не хватает:

```elixir
case topic.priority do
  :high -> do_something
  :medium -> do_something_else
end
```

То компилятор выдаёт ошибку "не обработано значение :low".

Это важно при изменениях в данных, когда добавляется новое значение в Enum, и нужно найти и обновить все места в коде, где эти данные обрабатываются.

Увы, компилятор Эликсир и Dialyzer этого не делают.


# Что такое функциональное программирование?

Не так просто сформулировать, что такое функциональное программирование. И я даже не пытался делать это в начале курса. Но сейчас, когда курс приближается к завершению, и у вас появился некоторый опыт ФП, можно попробовать разобраться.

Какого-то эталонного, "чистого" ФП не существует. Существуют языки программирования, которые традиционно относят к функциональным. И у них есть много общего, но есть и большие различия.

Когда говорят про функциональные языки, в первую очередь называют Lisp и Haskell. Кто-то вспомнит про Standad ML или OCaml. Наверняка не забудут Scala.

Однако Scala и OCaml -- это мультипарадигменные языки. На них можно писать в функциональном стиле, а можно совсем не использовать ФП. В эту же группу можно отнести Rust.

Наконец, есть популярные, "меинстримовые" языки, которые изначально не были функциональным, но со временем позаимствовали некоторые элементы ФП. Например, это Java, C++, Python, JavaScript.

Давайте зацепимся за "элементы ФП" и рассмотрим их. Многие из этих элементов мы уже изучили в рамках курса.


## Элементы ФП

Итак, для функционального программирования характерно:
- Иммутабельные данные (Immutability);
- Рекурсия, как основной способ итерации по спискам и другим коллекциям;
- Функции высшего порядка (HOF) и высокоуровневые средства работы с коллекциями (map, filter, reduce/fold);
- Анонимные функции (замыкания, лямбды);
- Алгебраические типы данных (ADT);
- Сопоставление с образцом (Pattern Matching);
- Ленивые вычисления (Lazy Evaluation).

Это то, что мы видели в Эликсир.

Кроме этого еще есть:
- Автоматический вывод типов (Type Inference) в языках со статической типизацией;
- Чистые функции и контроль побочных эффектов.

Иммутабельность мы обсуждали в 4-м уроке. Это важная часть ФП, которая исключает класс ошибок, связанных с модификацией одной области памяти из разных мест в коде, что упрощает многие аспекты разработки: многопоточность, отладку, статический анализ кода.

Итерация на основе рекурсии, функции высшего порядка, map, filter, reduce -- здесь у вас уже есть практика и личный опыт. Пожалуй, именно в этих элементах все функциональные языки наиболее похожи друг на друга. Их синтаксис может сильно отличаться, но семантика остается одна и та же.

Анонимные функции и замыкания дополняют HOF и добавляют удобства в разработке. Эти элементы часто встречаются и в не-функциональных языках, но там они могут выполнять другую роль. Например, в JavaScript вы часто увидите анонимную функцию в роли функции обратного вызова (callback) в асинхронном коде.

Сопоставление с образцом (Pattern Matching) такая же неотъемлемая часть ФП, как рекурсия и HOF. Этот элемент, являясь основным способом реализации условных переходов, тоже сильно отличает функциональный код от императивного.

Алгебраические типы данных определяют то, как мы моделируем сущности в нашей программе. Они следуют идее четкого разделения данных и функций, что отличает их от объектно-ориентированного программирования.

Ленивые вычисления не являются такой уж спецификой ФП, они есть и в других языках. Но их ассоциируют в первую очередь с языком Хаскель. В Хаскель любые вычисения являются ленивыми, что отличает его от большинства других языков, в т.ч. функциональных.

Автоматический вывод типов сейчас есть во многих мейнстримовых языках, например, в C++ и Java. В 80-90-е годы это было характерно для ФП, а в мейнстрим проникло позже.

Контроль побочных эффектов -- вторая важная особенность Хаскель. В большинстве языков чистота функций, отсутствие в них побочных эффектов -- это ответсвенность разработчика. Но в Хаскель это контролирует компилятор. Компилятор не позволяет разработчику написать код, где побочные эффекты не указаны явно.

Чистый код:
- легче понять
- легче компоновать
- содержит меньше ошибок

В Эликсир тоже важно стремиться к чистым функциям, и это возможно на уровне одного потока. Однако любая Эликсир-система насыщена взаимодействием между потоками. Это взаимодействие реализуется через отправку сообщений, а отправка сообщения является побочным эффектом.

Чистая функция:

```elixir-iex
> f = fn(m) -> Map.fetch(m, :a) end
> f.(%{a: 42})
{:ok, 42}
```

Функция с побочным эффектом:

```elixir-iex
> f = fn(m) -> v = Map.fetch(m, :a)
...> send(self(), v)
...> v
...> end
> f.(%{a: 42})
{:ok, 42}
```

Кроме получения результата вызова функции, еще было отправлено сообщение процессу self(), и это сообщение теперь можно увидеть в почтовом ящике процесса:

```elixir-iex
> flush()
{:ok, 42}
:ok
```

Теперь, когда мы рассмотрели элементы ФП, мы можем сказать, что такое ФП. ФП -- это то, что **в основном** состоит из этих элементов. На практике в функциональной программе может встречаться многое: мутабельная память, циклы for вместо рекурсии, побочные эффекты и прочее, но все это будет составлять небольшую часть программы. Допустим, 5%, а остальные 95% -- это описаные выше элементы ФП.

Императивные языки тоже могут использовать элементы ФП, но там пропорция будет, допустим, 80/20, или 90/10, или 100/0.
